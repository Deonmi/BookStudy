



# 尚学堂JAVA学习笔记

[TOC]

## 写在前面

学习链接：[Java 视频教程全集](https://www.bilibili.com/video/av59529105/)

课件链接：[Java课件](https://www.sxt.cn/Java_jQuery_in_action/History_Direction.html)

## 第1章 JAVA入门

- 计算机语言发展史以及未来方向

  - 第一代语言：机器语言
  
- 第二代语言：汇编语言
  
- 第三代语言：高级语言
  
- Java的核心优势

  -   JAVA虚拟机是JAVA实现跨平台的核心。

- Java的各个版本

  ![2017-6-6 10-12-07.jpg](https://www.sxt.cn/360shop/Public/admin/UEditor/20170606/1496714683708833.jpg)

  - JavaSE(Java Standard Edition)：标准版，定位在个人计算机上的应用。

  - JavaEE(Java Enterprise Edition)：企业版，定位在服务器端的应用。

  - JavaME(Java Micro Edition)：微型版，定位在消费性电子产品的应用上。

  - 雷区：很多人开始会误解为**安卓开发**就是JavaME，这两个是完全不同的内容。

- Java的特征和优势

  - 跨平台/可以执行
  - 安全性
  - 面相对象
  - 简单性
  - 高性能
  - 分布式
  - 多线程
  - 健壮性

- Java应用程序的运行机制

  ![å¾ç6.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494836063440655.png)

  - Java首先利用文本编辑器编写 Java源程序，源文件的后缀名为.java；再利用编译器（javac）将源程序编译成字节码文件，字节码文件的后缀名为.class； 最后利用虚拟机（解释器，java）解释执行。

- JVM、JRE和JDK

  - JVM(Java Virtual Machine)就是一个虚拟的用于执行bytecode字节码的”虚拟计算机”。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。JVM负责将Java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。
  
    ![图片8.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837984812122.png)
  
  -  Java Runtime Environment (JRE) 包含：Java虚拟机、库函数、运行Java应用程序所必须的文件。
  
  - Java  Development Kit (JDK)包含：包含JRE，以及增加编译器和调试器等用于程序开发的文件
  
    ![图片7.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837979897855.png)
  
- 第一个Java程序的总结和提升

  - 一个源文件可以包含多个类class。
  - 正确编译后的源文件，会得到相应的字节码文件，编译器为每个类生成独立的字节码文件，且将字节码文件自动命名为类的名字且以“.class”为扩展名。

- 最常用DOS命令

  - **cd  目录路径**：进入一个目录
  - **cd ..**：进入父目录
  - **dir**：查看本目录下的文件和子目录列表
  - **cls**：清楚屏幕命令
  - **上下键**：查找敲过的命令
  - **Tab键**：自动补齐命令

## 第2章 数据类型和运算符

- 注释

  - 单行注释：  使用“//”开头，“//”后面的单行内容均为注释。
  - 多行注释：   以“`/*`”开头以“`*/`”结尾，在“`/*`”和“`*/`”之间的内容为注释，我们也可以使用多行注释作为行内注释。但是在使用时要注意，多行注释不能嵌套使用。
  - 文档注释：   以“`/**`”开头以“*/”结尾，注释中包含一些说明性的文字及一些JavaDoc标签(后期写项目时，可以生成项目的API)

- 标识符

  - 标识符必须以字母、下划线_、美元符号$开头。  
  - 标识符其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合。
  - Java 标识符大小写敏感，且长度无限制。
  - 标识符不可以是Java的关键字。
  - **标识符的使用规范**
    - 表示类名的标识符：每个单词的首字母大写，如Man, GoodMan
    - 表示方法和变量的标识符：第一个单词小写，从第二个单词开始首字母大写，我们称之为“驼峰原则”，如eat(), eatFood()

- Java中的关键字/保留字

  ![img](https://img-blog.csdnimg.cn/20190820100643778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 变量的分类

  - **局部变量(local  variable)**：方法或语句块内部定义的变量。生命周期是从声明位置开始到到方法或语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用。
  - **成员变量（也叫实例变量  member variable）**：方法外部、类的内部定义的变量。从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型的默认初始值。
  - **静态变量（类变量 static variable）**：使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。 (注：讲完内存分析后我们再深入！先放一放这个概念！)如果不自行初始化，与成员变量相同会自动初始化成该类型的默认初始值。

  ![img](https://img-blog.csdnimg.cn/20190820101435964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 变量和常量命名规范（规范是程序员的基本准则，不规范会直接损害你的个人形象）：

  1. 所有变量、方法、类名：见名知意
  2. 类成员变量：首字母小写和驼峰原则:  monthSalary
  3. 局部变量：首字母小写和驼峰原则
  4. 常量：大写字母和下划线：MAX_VALUE
  5. 类名：首字母大写和驼峰原则:  Man, GoodMan
  6. 方法名：首字母小写和驼峰原则: run(), runRun()

- 基本数据类型(primitive data type)

  ![7.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170607/1496834727293971.png)

  - 引用数据类型的大小统一为4个字节，记录的是其引用对象的地址！

- 整型变量/常量

  ![img](https://img-blog.csdnimg.cn/201908201021227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - **Java 语言整型常量的四种表示形式**
    - 十进制整数，如：99, -500, 0
    - 八进制整数，要求以 0 开头，如：015
    - 十六进制数，要求 0x 或 0X 开头，如：0x15
    - 二进制数，要求0b或0B开头，如：0b01110011
  - Java语言的整型常数默认为int型，声明long型常量可以后加‘ l ’或‘ L ’ 。

- 浮点型变量/常量

  ![img](https://img-blog.csdnimg.cn/20190820102728805.png)

  - **Java浮点类型常量有两种表示形式**
    - 十进制数形式，例如:3.14       314.0      0.314 
    - 科学记数法形式，如314e2      314E2      314E-2 
  - 浮点类型float，double的数据不适合在不容许舍入误差的金融计算领域。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类。
  -  java.math包下面的两个有用的类：BigInteger和BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。
  - 不要使用浮点数进行比较！很多新人甚至很多理论不扎实的有工作经验的程序员也会犯这个错误！需要比较请使用BigDecimal类。

- 字符型变量/常量

  -  char 类型用来表示在Unicode编码表中的字符。Unicode编码被设计用来处理各种语言的文字，它占2个字节，可允许有65536个字符。

  - 转义字符

    ![img](https://img-blog.csdnimg.cn/2019082013142555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - String类，其实是字符序列(char sequence)。

- 运算符(operator)

  ![img](https://img-blog.csdnimg.cn/20190820132031732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 算术运算符

  - **取模运算：**
    - 其操作数可以为浮点数,一般使用整数，结果是“余数”，“余数”符号和左边操作数相同，如：7%3=1，-7%3=-1，7%-3=1。

- 赋值及其扩展赋值运算符

  ![img](https://img-blog.csdnimg.cn/20190820134803620.png)

- 关系运算符

  ![img](https://img-blog.csdnimg.cn/20190820135041134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 逻辑运算符

  ![img](https://img-blog.csdnimg.cn/20190820171632640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - 短路与和短路或采用短路的方式。从左到右计算，如果只通过运算符左边的操作数就能够确定该逻辑表达式的值，则不会继续计算运算符右边的操作数，提高效率。

- 位运算符

  ![img](https://img-blog.csdnimg.cn/20190820172203250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 运算符的优先级

  ![img](https://img-blog.csdnimg.cn/20190820175143719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - 逻辑与、逻辑或、逻辑非的优先级一定要熟悉！（逻辑非>逻辑与>逻辑或）。

- 自动类型转换

  - 自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型。实线表示无数据丢失的自动类型转换，而虚线表示在转换时可能会有精度的损失。

    ![1.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494906265693111.png)

  - 可以将整型常量直接赋值给byte、 short、 char等类型变量，而不需要进行强制类型转换，只要不超出其表数范围即可。

## 第3章 控制语句

- 带标签的break和continue

  - “标签”是指后面跟一个冒号的标识符，例如：“label:”。对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。

  - 在 “goto有害”论中，最有问题的就是标签，而非goto， 随着标签在一个程序里数量的增多，产生错误的机会也越来越多。 但Java标签不会造成这方面的问题，因为它们的活动场所已被限死，不可通过特别的方式到处传递程序的控制权。由此也引出了一个有趣的问题：**通过限制语句的能力，反而能使一项语言特性更加有用。**

  - 带标签break和continue：控制嵌套循环跳转(打印101-150之间所有的质数)

    ```java
    public class Test18 {
        public static void main(String args[]) {
            outer: for (int i = 101; i < 150; i++) {
                for (int j = 2; j < i / 2; j++) {
                    if (i % j == 0){
                        continue outer;
                    }
                }
                System.out.print(i + "  ");
            }
        }
    }
    ```

- 方法

  - Java中进行方法调用中传递参数时，遵循值传递的原则(传递的都是数据的副本)：
    - 基本类型传递的是该数据值的copy值。
    - 引用类型传递的是该对象引用的copy值，但指向的是同一个对象。

- 方法的重载(overload)

  - 方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。 调用时，会根据不同的参数自动匹配对应的方法。

  - 重载的方法，实际是完全不同的方法，只是名称相同而已!

  - 构成方法重载的条件：

    1. 不同的含义：**形参类型**、**形参个数**、**形参顺序不同**

    2. 只有返回值不同不构成方法的重载
    3. 只有形参的名称不同，不构成方法的重载

- 递归结构

  - 递归是一种常见的解决问题的方法，即把问题逐渐简单化。递归的基本思想就是“自己调用自己”，一个使用递归技术的方法将会直接或者间接的调用自己。

  - 递归结构包括两个部分：

    1. 定义递归头。解答：什么时候不调用自身方法。如果没有头，将陷入死循环，也就是递归的结束条件。

    2. 递归体。解答：什么时候需要调用自身方法。

  - **递归的缺陷**

    - 简单的程序是递归的优点之一。但是递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环慢的多，所以在使用递归时要慎重。
    - 任何能用递归解决的问题也能使用迭代解决。当递归方法可以更加自然地反映问题，并且易于理解和调试，并且不强调效率问题时，可以采用递归;
    - 在要求高性能的情况下尽量避免使用递归，递归调用既花时间又耗内存。

## 第4章 Java面向对象基础

### 1. 面向对象基础

- **类：**我们叫做class。
- **对象：**我们叫做Object,instance(实例)。以后我们说某个类的对象，某个类的实例。是一样的意思。

### 2. 面向对象的内存分析

- Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。

- **栈的特点如下：**

  1. 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(==存储局部变量、操作数、方法出口==等)

  2. JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)

  3. 栈属于线程私有，不能实现线程间的共享!

  4. 栈的存储特性是“先进后出，后进先出”

  　　5. 栈是由系统自动分配，速度快!栈是一个连续的内存空间!

-  **堆的特点如下：**

   1. 堆用于存储创建好的==对象和数组==(数组也是对象)

   2. JVM只有一个堆，被所有线程共享

   3. 堆是一个不连续的内存空间，分配灵活，速度慢!

- **方法区(又叫静态区)特点如下：**

  1. JVM只有一个方法区，被所有线程共享!

  2. 方法区实际也是堆，只是用于存储类、常量相关的信息!

  3. 用来存放程序中永远是不变或唯一的内容。(==类信息==【Class对象】、==静态变量、字符串常量==等)

  ![1.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494925174358420.png)

  ![neicunfenxi.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20171026/1509008324820095.png)

### 3. 构造方法

- 构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。

- **要点：**

  1. 通过new关键字调用!!

  2. 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。

  3. 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加!

  4. 构造器的方法名必须和类名一致!
- **构造方法的重载**：

  - 构造方法也是方法，只不过有特殊的作用而已。与普通方法一样，构造方法也可以重载。
  - 构造方法的第一句总是super()
  - this表示创建好的对象

### 4. 垃圾回收机制(Garbage Collection)

- Java引入了垃圾回收机制，令C++程序员最头疼的内存管理问题迎刃而解。Java程序员可以将更多的精力放到业务逻辑上而不是内存管理工作上，大大的提高了开发效率。

- **内存管理**

  - Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。

  - 对象空间的分配：使用new关键字创建对象即可
  - 对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。

- **垃圾回收过程**

  任何一种垃圾回收算法一般要做两件基本事情：

  1. 发现无用的对象

  2. 回收无用对象占用的内存空间。

  垃圾回收机制保证可以将“无用的对象”进行回收。无用的对象指的就是没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。

- **垃圾回收相关算法**

  1. 引用计数法

     堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。

  2. 引用可达法(根搜索算法)

     程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。

- **通用的分代垃圾回收机制**

  - 分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。

    1. 年轻代

       所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。

    2. 年老代

       在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。

    3. 持久代

       用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。

  - 堆内存的划分细节

    ![1.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494926399617250.png)

    - Minor GC：

      用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空)

    - Major GC：

      用于清理老年代区域。

    - Full GC：

      用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。

  - 垃圾回收过程：

    1、新创建的对象，绝大多数都会存储在Eden中，

    2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区

    3、当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。

    4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，

    5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）

- **JVM调优和Full GC**

  - 在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：

    　　1.年老代(Tenured)被写满

      　　2.持久代(Perm)被写满

      　　3.System.gc()被显式调用（程序建议GC启动，不是调用GC）

      　　4.上一次GC之后Heap的各域分配策略动态变化

- **开发中容易造成内存泄露的操作**

  - 创建大量无用对象：

    比如，我们在需要大量拼接字符串时，使用了String而不是StringBuilder。

  - 静态集合类的使用：

    像HashMap、Vector、List等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放。

  - 各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭：

    IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不使用的时候一定要关闭。

  - 监听器的使用：

    释放对象时，没有删除相应的监听器。

- **要点：**

  　　1. 程序员无权调用垃圾回收器。

        　　2. 程序员可以调用System.gc()，该方法只是通知JVM，并不是运行垃圾回收器。尽量少用，会申请启动Full GC，成本高，影响系统性能。

            　　3. finalize方法，是Java提供给程序员用来释放对象或资源的方法，但是尽量少用。

### 5. this关键字

- **对象创建的过程和this的本质**
- 构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步：
  
  1. 分配对象空间，并将对象成员变量初始化为0或空
  
  2. 执行属性值的显示初始化
  
  3. 执行构造方法
  
  4. 返回对象的地址给相关的变量
  
- this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。
  
- this最常的用法：
  
  1. 在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。
  
  2. 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。
  
  3. this不能用于static方法中。

### 6. static 关键字

- 在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点：

  1. 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。

  2. 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!

  3. 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。)

  4. 在static方法中不可直接访问非static的成员。

- static修饰的成员变量和方法，从属于类。

- 普通变量和方法从属于对象的。

![2.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494927332527045.png)

### 7. 静态初始化块

- 构造方法用于对象的初始化!静态初始化块，用于类的初始化操作!在静态初始化块中不能直接访问非static成员。

- 静态初始化块执行顺序：

  1. 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。

  2. 构造方法执行顺序和上面顺序一样!!

### 8. 参数传值机制

- Java中，方法中所有参数都是“值传递”，也就是“传递的是值的副本”。 也就是说，我们得到的是“原参数的复印件，而不是原件”。因此，复印件改变不会影响原件。
- **基本数据类型参数的传值**
  - 传递的是值的副本。 副本改变不会影响原件。
- **引用类型参数的传值**
  - 传递的是值的副本。但是引用类型指的是“对象的地址”。因此，副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变”。

### 9. 包

- 包机制是Java中管理类的重要手段。 开发中，我们会遇到大量同名的类，通过包我们很容易对解决类重名的问题，也可以实现对类的有效管理。 包对于类，**相当于文件夹对于文件的作用**。

- 我们通过package实现对类的管理，package的使用有两个要点：

  1. 通常是类的第一句非注释性语句。

  2. 包名：域名倒着写即可，再加上模块名，便于内部管理类。

- **注意事项：**

  1. 写项目时都要加包，不要使用默认包。

  2. com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分。

- **JDK中的主要包**

  ![img](https://img-blog.csdnimg.cn/20190828195429515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- **导入类import**

  - 如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性。

  - **注意要点：**

    1. Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。

    2. 如果导入两个同名的类，只能用包名+类名来显示调用相关类。

- **静态导入**

  - 静态导入(static import)是在JDK1.5新增加的功能，其作用是用于导入指定类的静态属性，这样我们可以直接使用静态属性。

    ```java
    package cn.sxt;
     //以下两种静态导入的方式二选一即可
    import static java.lang.Math.*;//导入Math类的所有静态属性
    import static java.lang.Math.PI;//导入Math类的PI属性
     
    public class Test2{
        public static void main(String [] args){
            System.out.println(PI);
            System.out.println(random());
        }
    }
    ```

## 第5章 Java面向对象进阶

### 1. 继承

- **继承的实现**

  - 继承让我们更加容易实现类的扩展。 比如，我们定义了人类，再定义Boy类就只需要扩展人类即可。实现了代码的重用，不用再重新发明轮子(don’t  reinvent  wheels)。

  - 从英文字面意思理解，extends的意思是“扩展”。子类是父类的扩展。现实世界中的继承无处不在。比如：

    ![图5-1 现实世界中的继承.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170519/1495179917567916.png)

- **继承使用要点**

  1. 父类也称作超类、基类、派生类等。

  2. Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。

  3. Java中类没有多继承，接口有多<u>继承</u>（？？**实现**）。

  4. 子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。

  5. 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。
  6. 可以使用ctrl+T方便的查看继承结构。

- **instanceof 运算符**

  - instanceof是二元运算符，左边是对象，右边是类；当对象是右面类或子类所创建对象时，返回true；否则，返回false。
  
- **方法的重写override**

  - 子类通过重写父类的方法，可以用自身的行为替换父类的行为。**方法的重写是实现多态的必要条件**。

  - **方法的重写需要符合下面的三个要点：**

    ​      1.“==”： 方法名、形参列表相同。

    ​      2.“≤”：返回值类型和声明异常类型，子类小于等于父类。

    ​      3.“≥”： 访问权限，子类大于等于父类。

### 2. Object类

- Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。如果在类的声明中未使用extends关键字指明其父类，则默认继承Object类。

- **toString方法**

  - Object类中定义有public String toString()方法，其返回值是 String 类型。

  - Object类中toString方法的源码为：

    ```java
    public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
    ```

  - 根据如上源码得知，默认会返回“类名+@+16进制的hashcode”。在打印输出或者用字符串连接对象时，会自动调用该对象的toString()方法。

- **==和equals方法**

  - “==”代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。
  - Object类中定义有：public boolean equals(Object obj)方法，提供定义“对象内容相等”的逻辑。比如，我们在公安系统中认为id相同的人就是同一个人、学籍系统中认为学号相同的人就是同一个人。
  - Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。但是，我们可以根据我们自己的要求重写equals方法。
  - JDK提供的一些类，如String、Date、包装类等，重写了Object的equals方法，调用这些类的equals方法， x.equals (y) ，当x和y所引用的对象是同一类对象且属性内容相等时（并不一定是相同对象），返回 true 否则返回 false。

### 3. super关键字

- super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。

- 使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。

- 若是构造方法的第一行代码没有显式的调用super(...)或者this(...);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。

- **继承树追溯**

  - **属性/方法查找顺序：(比如：查找变量h)**

    1. 查找当前类中有没有属性h

    2. 依次上溯每个父类，查看每个父类中是否有h，直到Object

    3. 如果没找到，则出现编译错误。

    4. 上面步骤，只要找到h变量，则这个过程终止。

  - **构造方法调用顺序：**

    - 构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。
    - 注：**静态初始化块**调用顺序，与构造方法调用顺序一样，不再重复。

### 4. 封装



