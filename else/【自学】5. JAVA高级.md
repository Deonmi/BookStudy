#  尚学堂JAVA高级学习笔记

[TOC]

## 写在前面

学习链接：[Java 视频教程全集](https://www.bilibili.com/video/av59529105/)

课件链接：[Java课件](https://www.sxt.cn/Java_jQuery_in_action/History_Direction.html)

## 第1章 手写webserver

### 1. 灵魂反射

- 反射Reflection：把java类中的各种结构（方法、属性、构造器、类名）映射成一个个的java对象。利用反射技术可以对一个类进行解剖，反射是框架设计的灵魂。

- 获取Class对象（三种方式）：推荐使用Class.forName(“完整路径”)

- 可以动态创建对象：clz.getConstructor().newInstance()

- 练习

  ```java
  package com.sxt.Server_study01;
  
  import java.lang.reflect.InvocationTargetException;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: ReflectTest.java
   * @time: 2019/11/29 14:55
   * @desc:
   */
  
  public class ReflectTest {
      public static void main(String[] args){
          // 1. 对象.getClass() | 买iphone照着做
          Iphone iphone = new Iphone();
          Class clz = iphone.getClass();
          // 2. 类.class()     | 买通工程师给图纸
          clz = Iphone.class;
          // 3. Class.forName("包名.类名")   | 偷图纸
          try {
              clz = Class.forName("com.sxt.Server_study01.Iphone");
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
  
          // 创建对象
          try {
              Iphone iphone2 = (Iphone)clz.newInstance();
              System.out.println(iphone2);
          } catch (InstantiationException | IllegalAccessException e) {
              e.printStackTrace();
          }
          // 创建对象推荐方式
          try {
              Iphone iphone3 = (Iphone)clz.getConstructor().newInstance();
              System.out.println(iphone3);
          } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
              e.printStackTrace();
          }
      }
  }
  
  class Iphone{
      public Iphone(){
      }
  }
  ```

### 2. 高效解析xml

- XML：Extensible Markup Language，可扩展标记语言，作为数据的一种存储格式或用于存储软件的参数，程序解析此配置文件，就可以达到不修改代码就能更改程序的目的。

- 利用Sax解析XML

- xml例子

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <persons>
      <person>
          <name>至尊宝</name>
          <age>9000</age>
      </person>
      <person>
          <name>白晶晶</name>
          <age>7000</age>
      </person>
  </persons>
  ```

- 制作Person类

  ```java
  package com.sxt.Server_study01;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Person.java
   * @time: 2019/11/29 15:29
   * @desc:
   */
  
  public class Person {
      private String name;
      private int age;
  
      public Person() {
      }
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public int getAge() {
          return age;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
  }
  ```

- 熟悉sax解析流程

  ```java
  package com.sxt.Server_study01;
  
  import org.xml.sax.Attributes;
  import org.xml.sax.SAXException;
  import org.xml.sax.helpers.DefaultHandler;
  
  import javax.xml.parsers.ParserConfigurationException;
  import javax.xml.parsers.SAXParser;
  import javax.xml.parsers.SAXParserFactory;
  import java.io.IOException;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: XmlTest01.java
   * @time: 2019/11/29 15:10
   * @desc: 熟悉sax解析流程
   */
  
  public class XmlTest01 {
      public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException {
          // SAX解析
          // 1. 获取解析工厂
          SAXParserFactory factory = SAXParserFactory.newInstance();
          // 2. 从解析工厂获取解析器
          SAXParser parse = null;
          parse = factory.newSAXParser();
          // 3. 加载文档Document注册处理器
          // 4. 编写处理器
          PHandler handler = new PHandler();
          parse.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("com/sxt/Server_study01/p.xml"), handler);
      }
  }
  
  class PHandler extends DefaultHandler {
      @Override
      public void startDocument() throws SAXException {
          System.out.println("解析文档开始");
      }
  
      @Override
      public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
          System.out.println(qName + "-->解析开始");
      }
  
      @Override
      public void characters(char[] ch, int start, int length) throws SAXException {
          String contents = new String(ch, start, length).trim();
          if(contents.length()>0) {
              System.out.println("内容为：" + contents);
          }else{
              System.out.println("内容为空！");
          }
      }
  
      @Override
      public void endDocument() throws SAXException {
          System.out.println("解析文档结束");
      }
  
      @Override
      public void endElement(String uri, String localName, String qName) throws SAXException {
          System.out.println(qName + "-->解析结束");
      }
  }
  ```

- 获取xml中的内容

  ```java
  package com.sxt.Server_study01;
  
  import org.xml.sax.Attributes;
  import org.xml.sax.SAXException;
  import org.xml.sax.helpers.DefaultHandler;
  
  import javax.xml.parsers.ParserConfigurationException;
  import javax.xml.parsers.SAXParser;
  import javax.xml.parsers.SAXParserFactory;
  import java.io.IOException;
  import java.util.ArrayList;
  import java.util.List;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: XmlTest02.java
   * @time: 2019/11/29 15:31
   * @desc: 获取xml中的内容
   */
  
  public class XmlTest02 {
      public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException {
          // SAX解析
          // 1. 获取解析工厂
          SAXParserFactory factory = SAXParserFactory.newInstance();
          // 2. 从解析工厂获取解析器
          SAXParser parse = null;
          parse = factory.newSAXParser();
          // 3. 加载文档Document注册处理器
          // 4. 编写处理器
          PersonHandler handler = new PersonHandler();
          parse.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("com/sxt/Server_study01/p.xml"), handler);
          // 5. 获取数据
          List<Person> persons = handler.getPersons();
          for (Person p : persons) {
              System.out.println(p.getName() + "-->" + p.getAge());
          }
      }
  }
  
  class PersonHandler extends DefaultHandler {
      private List<Person> persons;
      private Person person;
      private String tag;     // 存储操作的标签
  
      @Override
      public void startDocument() throws SAXException {
          System.out.println("解析文档开始");
          persons = new ArrayList<>();
      }
  
      @Override
      public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
          if (null != qName) {
              tag = qName;        // 存储标签名
              if (tag.equals("person")) {
                  person = new Person();
              }
          }
      }
  
      @Override
      public void characters(char[] ch, int start, int length) throws SAXException {
          String contents = new String(ch, start, length).trim();
          if (contents.length() > 0) {
              if (tag.equals("name")) {
                  person.setName(contents);
              } else if (tag.equals("age")) {
                  person.setAge(Integer.valueOf(contents));
              }
          }
      }
  
      @Override
      public void endElement(String uri, String localName, String qName) throws SAXException {
          if (qName.equals("person")) {
              persons.add(person);
          }
      }
  
      @Override
      public void endDocument() throws SAXException {
          System.out.println("解析文档结束");
      }
  
      public List<Person> getPersons() {
          return persons;
      }
  }
  ```

### 3. 解析webxml

- webxml例子

  ```java
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app>
      <servlet>
          <servlet-name>login</servlet-name>
          <servlet-class>com.sxt.server.basic.servlet.LoginServlet</servlet-class>
      </servlet>
      <servlet>
          <servlet-name>reg</servlet-name>
          <servlet-class>com.sxt.server.basic.servlet.RegisterServlet</servlet-class>
      </servlet>
      <servlet-mapping>
          <servlet-name>login</servlet-name>
          <url-pattern>/login</url-pattern>
          <url-pattern>/g</url-pattern>
      </servlet-mapping>
      <servlet-mapping>
          <servlet-name>reg</servlet-name>
          <url-pattern>/reg</url-pattern>
      </servlet-mapping>
  </web-app>
  ```

- 解析webxml

  ```java
  package com.sxt.Server_study01.servlet;
  
  import com.sxt.Server_study01.Person;
  import org.xml.sax.Attributes;
  import org.xml.sax.SAXException;
  import org.xml.sax.helpers.DefaultHandler;
  
  import javax.xml.parsers.ParserConfigurationException;
  import javax.xml.parsers.SAXParser;
  import javax.xml.parsers.SAXParserFactory;
  import java.io.IOException;
  import java.util.ArrayList;
  import java.util.List;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: XmlTest02.java
   * @time: 2019/11/29 15:31
   * @desc: 解析Webxml
   */
  
  public class XmlTest02 {
      public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException {
          // SAX解析
          // 1. 获取解析工厂
          SAXParserFactory factory = SAXParserFactory.newInstance();
          // 2. 从解析工厂获取解析器
          SAXParser parse = null;
          parse = factory.newSAXParser();
          // 3. 加载文档Document注册处理器
          // 4. 编写处理器
          WebHandler handler = new WebHandler();
          parse.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("com/sxt/Server_study01/servlet/web.xml"), handler);
          // 5. 获取数据
          List<Entity> entitys = handler.getEntitys();
          List<Mapping> mappings = handler.getMappings();
          System.out.println(entitys.size());
          System.out.println(mappings.size());
      }
  }
  
  class WebHandler extends DefaultHandler {
      private List<Entity> entitys;
      private List<Mapping> mappings;
      private Entity entity;
      private Mapping mapping;
      private String tag;
      private boolean isMapping = false;
  
      public List<Entity> getEntitys() {
          return entitys;
      }
  
      public void setEntitys(List<Entity> entitys) {
          this.entitys = entitys;
      }
  
      public List<Mapping> getMappings() {
          return mappings;
      }
  
      public void setMappings(List<Mapping> mappings) {
          this.mappings = mappings;
      }
  
      @Override
      public void startDocument() throws SAXException {
          entitys = new ArrayList<>();
          mappings = new ArrayList<>();
      }
  
      @Override
      public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
          if (null != qName) {
              tag = qName;        // 存储标签名
              if (tag.equals("servlet")) {
                  entity = new Entity();
                  isMapping = false;
              } else if (tag.equals("servlet-mapping")) {
                  mapping = new Mapping();
                  isMapping = true;
              }
          }
      }
  
      @Override
      public void characters(char[] ch, int start, int length) throws SAXException {
          String contents = new String(ch, start, length).trim();
          if (contents.length() > 0) {
              if (isMapping) {// 操作servlet-mapping
                  if (tag.equals("servlet-name")) {
                      mapping.setName(contents);
                  } else if (tag.equals("url-pattern")) {
                      mapping.addPattern(contents);
                  }
              } else {// 操作servlet
                  if (tag.equals("servlet-name")) {
                      entity.setName(contents);
                  } else if (tag.equals("servlet-class")) {
                      entity.setClz(contents);
                  }
              }
          }
      }
  
      @Override
      public void endElement(String uri, String localName, String qName) throws SAXException {
          if (qName.equals("servlet")) {
              entitys.add(entity);
          } else if (qName.equals("servlet-mapping")) {
              mappings.add(mapping);
          }
      }
  }
  ```

### 4. 反射webxml

- xml样例

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app>
      <servlet>
          <servlet-name>login</servlet-name>
          <servlet-class>com.sxt.Server_study01.servlet.LoginServlet</servlet-class>
      </servlet>
      <servlet>
          <servlet-name>reg</servlet-name>
          <servlet-class>com.sxt.Server_study01.servlet.RegisterServlet</servlet-class>
      </servlet>
      <servlet-mapping>
          <servlet-name>login</servlet-name>
          <url-pattern>/login</url-pattern>
          <url-pattern>/g</url-pattern>
      </servlet-mapping>
      <servlet-mapping>
          <servlet-name>reg</servlet-name>
          <url-pattern>/reg</url-pattern>
      </servlet-mapping>
  </web-app>
  ```

- 解析xml

  - Entity类

    ```java
    package com.sxt.Server_study01.servlet;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Entity.java
     * @time: 2019/12/2 13:20
     * @desc:
     */
    
    public class Entity {
        private String name;
        private String clz;
    
        public Entity() {
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public String getClz() {
            return clz;
        }
    
        public void setClz(String clz) {
            this.clz = clz;
        }
    }
    ```

  - Mapping类

    ```java
    package com.sxt.Server_study01.servlet;
    
    import java.util.HashSet;
    import java.util.Set;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Mapping.java
     * @time: 2019/12/2 13:21
     * @desc:
     */
    
    public class Mapping {
        private String name;
        private Set<String> patterns;
    
        public Mapping() {
            patterns = new HashSet<>();
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public Set<String> getPatterns() {
            return patterns;
        }
    
        public void setPatterns(Set<String> patterns) {
            this.patterns = patterns;
        }
    
        public void addPattern(String pattern){
            this.patterns.add(pattern);
        }
    }
    ```

  - 通过URL的路径找到了对应的class

    ```java
    package com.sxt.Server_study01.servlet;
    
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: WebContext.java
     * @time: 2019/12/3 10:51
     * @desc:
     */
    
    public class WebContext {
        private List<Entity> entitys = null;
        private List<Mapping> mappings = null;
    
        // key-->servlet-name  value-->servlet-class
        private Map<String, String> mappingMap = new HashMap<>();
        // key-->url-pattern  value-->servlet-name
        private Map<String, String> entityMap = new HashMap<>();
    
        public WebContext(List<Entity> entitys, List<Mapping> mappings) {
            this.entitys = entitys;
            this.mappings = mappings;
    
            // 将entity的List转成了对应的map
            for(Entity entity: entitys){
                entityMap.put(entity.getName(), entity.getClz());
            }
            // 将map的List转成了对应的map
            for(Mapping mapping: mappings){
                for(String pattern: mapping.getPatterns()){
                    mappingMap.put(pattern, mapping.getName());
                }
            }
        }
    
        // 通过URL的路径找到了对应的class
        public String getClz(String pattern) {
            String name = mappingMap.get(pattern);
            return entityMap.get(name);
        }
    }
    ```

  - 核心代码，取出数据

    ```java
    package com.sxt.Server_study01.servlet;
    
    import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;
    import org.xml.sax.Attributes;
    import org.xml.sax.SAXException;
    import org.xml.sax.helpers.DefaultHandler;
    
    import javax.xml.parsers.ParserConfigurationException;
    import javax.xml.parsers.SAXParser;
    import javax.xml.parsers.SAXParserFactory;
    import java.io.IOException;
    import java.util.ArrayList;
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: XmlTest02.java
     * @time: 2019/11/29 15:31
     * @desc: 解析Webxml
     */
    
    public class XmlTest02 {
        public static void main(String[] args) throws Exception {
            // SAX解析
            // 1. 获取解析工厂
            SAXParserFactory factory = SAXParserFactory.newInstance();
            // 2. 从解析工厂获取解析器
            SAXParser parse = null;
            parse = factory.newSAXParser();
            // 3. 加载文档Document注册处理器
            // 4. 编写处理器
            WebHandler handler = new WebHandler();
            parse.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("com/sxt/Server_study01/servlet/web.xml"), handler);
            // 5. 获取数据
            WebContext context = new WebContext(handler.getEntitys(), handler.getMappings());
            // 假设你输入了 /login or /g
            String className = context.getClz("/g");
            Class clz = Class.forName(className);
            Servlet servlet = (Servlet)clz.getConstructor().newInstance();
            System.out.println(servlet);
            servlet.service();
        }
    }
    
    class WebHandler extends DefaultHandler {
        private List<Entity> entitys;
        private List<Mapping> mappings;
        private Entity entity;
        private Mapping mapping;
        private String tag;
        private boolean isMapping = false;
    
        public List<Entity> getEntitys() {
            return entitys;
        }
    
        public void setEntitys(List<Entity> entitys) {
            this.entitys = entitys;
        }
    
        public List<Mapping> getMappings() {
            return mappings;
        }
    
        public void setMappings(List<Mapping> mappings) {
            this.mappings = mappings;
        }
    
        @Override
        public void startDocument() throws SAXException {
            entitys = new ArrayList<>();
            mappings = new ArrayList<>();
        }
    
        @Override
        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
            if (null != qName) {
                tag = qName;        // 存储标签名
                if (tag.equals("servlet")) {
                    entity = new Entity();
                    isMapping = false;
                } else if (tag.equals("servlet-mapping")) {
                    mapping = new Mapping();
                    isMapping = true;
                }
            }
        }
    
        @Override
        public void characters(char[] ch, int start, int length) throws SAXException {
            String contents = new String(ch, start, length).trim();
            if (contents.length() > 0) {
                if (isMapping) {// 操作servlet-mapping
                    if (tag.equals("servlet-name")) {
                        mapping.setName(contents);
                    } else if (tag.equals("url-pattern")) {
                        mapping.addPattern(contents);
                    }
                } else {// 操作servlet
                    if (tag.equals("servlet-name")) {
                        entity.setName(contents);
                    } else if (tag.equals("servlet-class")) {
                        entity.setClz(contents);
                    }
                }
            }
        }
    
        @Override
        public void endElement(String uri, String localName, String qName) throws SAXException {
            if (qName.equals("servlet")) {
                entitys.add(entity);
            } else if (qName.equals("servlet-mapping")) {
                mappings.add(mapping);
            }
        }
    }
    ```

  - Servlet接口

    ```java
    package com.sxt.Server_study01.servlet;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Servlet.java
     * @time: 2019/12/3 15:59
     * @desc:
     */
    
    public interface Servlet {
        void service();
    }
    ```

  - 需要被映射的类：Loginservlet

    ```java
    package com.sxt.Server_study01.servlet;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2019/12/3 15:59
     * @desc:
     */
    
    public class LoginServlet implements Servlet {
        @Override
        public void service() {
            System.out.println("LoginServlet");
        }
    }
    ```

  - 需要被映射的类：RegisterServlet

    ```java
    package com.sxt.Server_study01.servlet;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: RegisterServlet.java
     * @time: 2019/12/3 15:59
     * @desc:
     */
    
    public class RegisterServlet implements Servlet{
        @Override
        public void service() {
            System.out.println("RegisterServlet");
        }
    }
    ```

### 5. 简单易学的html

- HyperText Markup Language ，超文本标记语言，简单理解为浏览器使用的语言。

- name是后端用的，id是前端用的

  ```java
  <html>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <head>
          <title>第一个html登陆</title>
      </head>
      <body>
          <h1>表单的使用</h1>
          <pre>
              post: 提交，基于http协议不同  量大  请求参数url不可见  安全<br/>
              get: 默认，获取，基于http协议不同  量小  请求参数url可见  不安全<br/>
              action: 请求web服务器的资源 URL<br/>
              name: 作为后端使用，区分唯一，请求服务器，必须存在，数据不能提交<br/>
              id: 作为前端使用，区分唯一<br/>
          </pre>
          <form method="post" action="http://localhost:8888/index.html">
              用户名: <input type="text" name="uname" id="uname"/>
              密码: <input type="password" name="pwd" id="pwd"/>
              <input type="submit" value="登陆"/>
          </form>
      </body>
  </html>
  ```

### 6. 不得不提的http协议

- http请求协议

   ![img](https://img-blog.csdnimg.cn/20191204091941174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
   
- http响应协议

    ![img](https://img-blog.csdnimg.cn/20191204092305298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 7. 获取请求协议

- 使用ServerSocket建立与浏览器的连接，获取请求协议

  ```java
  package com.sxt.Server_study02;
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server01.java
   * @time: 2019/12/4 9:26
   * @desc: 使用ServerSocket建立与浏览器的连接，获取请求协议
   */
  
  public class Server01 {
      private ServerSocket serverSocket;
      public static void main(String[] args) {
          Server01 server = new Server01();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
          }
      }
  
      // 接受连接处理
      public void receive() {
          try {
              Socket client = serverSocket.accept();
              System.out.println("一个客户端建立了连接...");
              // 获取请求协议
              InputStream is = client.getInputStream();
              byte[] datas = new byte[1024*1024];
              int len = is.read(datas);
              String requstInfo = new String(datas, 0, len);
              System.out.println(requstInfo);
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("客户端错误...");
          }
      }
  
      // 停止服务
      public void stop() {
  
      }
  }
  ```

- 两种请求方法get和post：[GET和POST两种基本请求方法的区别](https://www.cnblogs.com/logsharing/p/8448446.html)，[GET 和 POST 到底有什么区别？]( https://www.zhihu.com/question/28586791?sort=created )

### 8. 返回响应协议

```java
package com.sxt.Server_study02;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Date;

/**
 * @author: Li Tian
 * @contact: litian_cup@163.com
 * @software: IntelliJ IDEA
 * @file: Server02.java
 * @time: 2019/12/4 9:26
 * @desc: 返回响应协议
 */

public class Server02 {
    private ServerSocket serverSocket;
    public static void main(String[] args) {
        Server02 server = new Server02();
        server.start();
    }

    // 启动服务
    public void start() {
        try {
            serverSocket = new ServerSocket(8888);
            receive();
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("服务器启动失败...");
        }
    }

    // 接受连接处理
    public void receive() {
        try {
            Socket client = serverSocket.accept();
            System.out.println("一个客户端建立了连接...");
            // 获取请求协议
            InputStream is = client.getInputStream();
            byte[] datas = new byte[1024*1024];
            int len = is.read(datas);
            String requstInfo = new String(datas, 0, len);
            System.out.println(requstInfo);

            StringBuilder content = new StringBuilder();
            content.append("<html>");
            content.append("<head>");
            content.append("<title>");
            content.append("服务器响应成功");
            content.append("</title>");
            content.append("</head>");
            content.append("<body>");
            content.append("终于回来了...");
            content.append("</body>");
            content.append("</html>");
            int size = content.toString().getBytes().length;
            StringBuilder responseInfo = new StringBuilder();
            String blank = " ";
            String CRLF = "\r\n";
            // 返回
            // 1. 响应行：HTTP/1.1 200 OK
            responseInfo.append("HTTP/1.1").append(blank);
            responseInfo.append(200).append(blank);
            responseInfo.append("OK").append(CRLF);
            // 2. 响应头（最后一行存在空行）：
            responseInfo.append("Date:").append(new Date()).append(CRLF);
            responseInfo.append("Server:").append("shsxt Server/0.0.1;charset=GBK").append(CRLF);
            responseInfo.append("Content-type:text/html").append(CRLF);
            responseInfo.append("Content-length:").append(size).append(CRLF);
            responseInfo.append(CRLF);
            // 3. 正文
            responseInfo.append(content.toString());
            // 写出到客户端
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
            bw.write(responseInfo.toString());
            bw.flush();
            bw.close();
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("客户端错误...");
        }
    }

    // 停止服务
    public void stop() {

    }
}
```

### 9. 封装响应信息

1. 动态添加内容print

2. 累加字节数的长度

3. 根据状态码拼接响应头协议

4. 根据状态码统一推送出去

   ```java
   package com.sxt.Server_study02;
   
   import java.io.IOException;
   import java.io.InputStream;
   import java.net.ServerSocket;
   import java.net.Socket;
   
   /**
    * @author: Li Tian
    * @contact: litian_cup@163.com
    * @software: IntelliJ IDEA
    * @file: Server03.java
    * @time: 2019/12/4 9:26
    * @desc: 封装响应信息
    */
   
   public class Server03 {
       private ServerSocket serverSocket;
       public static void main(String[] args) {
           Server03 server = new Server03();
           server.start();
       }
   
       // 启动服务
       public void start() {
           try {
               serverSocket = new ServerSocket(8888);
               receive();
           } catch (IOException e) {
               e.printStackTrace();
               System.out.println("服务器启动失败...");
           }
       }
   
       // 接受连接处理
       public void receive() {
           try {
               Socket client = serverSocket.accept();
               System.out.println("一个客户端建立了连接...");
               // 获取请求协议
               InputStream is = client.getInputStream();
               byte[] datas = new byte[1024*1024];
               int len = is.read(datas);
               String requstInfo = new String(datas, 0, len);
               System.out.println(requstInfo);
   
               Response response = new Response(client);
   
               // 关注了内容
               response.print("<html>");
               response.print("<head>");
               response.print("<title>");
               response.print("服务器响应成功");
               response.print("</title>");
               response.print("</head>");
               response.print("<body>");
               response.print("终于回来了...");
               response.print("</body>");
               response.print("</html>");
   
               // 关注了状态码
               response.pushToBrowser(200);
   
           } catch (IOException e) {
               e.printStackTrace();
               System.out.println("客户端错误...");
           }
       }
   
       // 停止服务
       public void stop() {
       }
   }
   ```

   ```java
   package com.sxt.Server_study02;
   
   import java.io.BufferedWriter;
   import java.io.IOException;
   import java.io.OutputStream;
   import java.io.OutputStreamWriter;
   import java.net.Socket;
   import java.util.Date;
   
   /**
    * @author: Li Tian
    * @contact: litian_cup@163.com
    * @software: IntelliJ IDEA
    * @file: Response.java
    * @time: 2019/12/5 9:17
    * @desc:
    */
   
   public class Response {
       private BufferedWriter bw;
       // 正文
       private StringBuilder content;
       // 协议头信息：状态行与请求头、回车
       private StringBuilder headInfo;
       // 正文的字节数
       private int len;
   
       private final String BLANK = " ";
       private final String CRLF = "\r\n";
   
       public Response() {
           content = new StringBuilder();
           headInfo = new StringBuilder();
           len = 0;
       }
   
       public Response(Socket client) {
           this();
           try {
               bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
           } catch (IOException e) {
               e.printStackTrace();
               headInfo = null;
           }
       }
   
       public Response(OutputStream os) {
           this();
           bw = new BufferedWriter(new OutputStreamWriter(os));
       }
       // 动态添加内容
       public Response print(String info){
           content.append(info);
           len += info.getBytes().length;
           return this;
       }
       public Response println(String info){
           content.append(info).append(CRLF);
           len += (info + CRLF).getBytes().length;
           return this;
       }
   
       // 推送响应信息
       public void pushToBrowser(int code) throws IOException {
           if (null == headInfo){
               code = 505;
           }
           createHeadInfo(code);
           bw.append(headInfo);
           bw.append(content);
           bw.flush();
       }
   
       // 构建头信息
       private void createHeadInfo(int code) {
           // 1. 响应行：HTTP/1.1 200 OK
           headInfo.append("HTTP/1.1").append(BLANK);
           headInfo.append(code).append(BLANK);
           switch (code) {
               case 200:
                   headInfo.append("OK").append(CRLF);
                   break;
               case 404:
                   headInfo.append("NOT FOUND").append(CRLF);
                   break;
               case 505:
                   headInfo.append("SERVER ERROR").append(CRLF);
                   break;
           }
   
           // 2. 响应头（最后一行存在空行）：
           headInfo.append("Date:").append(new Date()).append(CRLF);
           headInfo.append("Server:").append("shsxt Server/0.0.1;charset=GBK").append(CRLF);
           headInfo.append("Content-type:text/html").append(CRLF);
           headInfo.append("Content-length:").append(len).append(CRLF);
           headInfo.append(CRLF);
       }
   }
   ```

### 10. 封装请求信息

- 通过分解字符串获取method、URL和请求参数

- POST请求参数可能在请求体中存在

- 分解协议

  ```java
  package com.sxt.Server_study02;
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Request.java
   * @time: 2019/12/5 10:15
   * @desc:
   */
  
  public class Request {
      private String requestInfo;
      // 请求方式
      private String method;
      // 请求url
      private String url;
      // 请求参数
      private String queryStr;
  
      private final String BLANK = " ";
      private final String CRLF = "\r\n";
  
      public Request(Socket client) throws IOException {
          this(client.getInputStream());
      }
  
      public Request(InputStream is) {
          byte[] datas = new byte[1024 * 1024];
          int len;
          try {
              len = is.read(datas);
              this.requestInfo = new String(datas, 0, len);
          } catch (IOException e) {
              e.printStackTrace();
              return;
          }
          // 分解字符串
          parseRequestInfo();
      }
  
      private void parseRequestInfo() {
          System.out.println("---分解---");
          System.out.println("1. 获取请求方式：开头到第一个/");
          this.method = this.requestInfo.substring(0, this.requestInfo.indexOf("/")).toLowerCase().trim();
          System.out.println("2. 获取请求url：第一个/ 到HTTP/");
          System.out.println("可能包含请求参数?前面的url");
          // 1. 获取/的位置
          int startIdx = this.requestInfo.indexOf("/") + 1;
          // 2. 获取HTTP/的位置
          int endIdx = this.requestInfo.indexOf("HTTP/");
          // 3. 分割字符串
          this.url = this.requestInfo.substring(startIdx, endIdx);
          // 4. 获取？的位置
          int queryIdx = this.url.indexOf("?");
          if (queryIdx >= 0) {
              // 表示存在请求参数
              String[] urlArray = this.url.split("\\?");
              this.url = urlArray[0].trim();
              queryStr = urlArray[1].trim();
          }
          System.out.println(this.url);
  
          System.out.println("3. 获取请求参数：若果Get已经获取，如果post可能在请求体中");
          if (method.equals("post")) {
              String qStr = this.requestInfo.substring(this.requestInfo.lastIndexOf(CRLF)).trim();
              if (null == queryStr) {
                  queryStr = qStr;
              } else {
                  queryStr += "&" + qStr;
              }
          }
          queryStr = null == queryStr?"": queryStr;
          System.out.println(method + "-->" + url + "-->" + queryStr);
      }
  }
  ```

  ```java
  package com.sxt.Server_study02;
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server04.java
   * @time: 2019/12/4 9:26
   * @desc: 封装请求协议：获取method uri以及请求参数
   */
  
  public class Server04 {
      private ServerSocket serverSocket;
      public static void main(String[] args) {
          Server04 server = new Server04();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
          }
      }
  
      // 接受连接处理
      public void receive() {
          try {
              Socket client = serverSocket.accept();
              System.out.println("一个客户端建立了连接...");
              // 获取请求协议
              Request request = new Request(client);
  
              Response response = new Response(client);
  
              // 关注了内容
              response.print("<html>");
              response.print("<head>");
              response.print("<title>");
              response.print("服务器响应成功");
              response.print("</title>");
              response.print("</head>");
              response.print("<body>");
              response.print("终于回来了...");
              response.print("</body>");
              response.print("</html>");
  
              // 关注了状态码
              response.pushToBrowser(200);
  
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("客户端错误...");
          }
      }
  
      // 停止服务
      public void stop() {
  
      }
  }
  
  ```

- 分解参数

  ```java
  package com.sxt.Server_study02;
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.UnsupportedEncodingException;
  import java.net.Socket;
  import java.util.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Request2.java
   * @time: 2019/12/5 10:15
   * @desc: 封装请求协议：封装请求参数为Map
   */
  
  public class Request2 {
      private String requestInfo;
      // 请求方式
      private String method;
      // 请求url
      private String url;
      // 请求参数
      private String queryStr;
      // 存储参数
      private Map<String, List<String>> parameterMap;
  
      private final String BLANK = " ";
      private final String CRLF = "\r\n";
  
      public Request2(Socket client) throws IOException {
          this(client.getInputStream());
      }
  
      public String getMethod() {
          return method;
      }
  
      public String getUrl() {
          return url;
      }
  
      public String getQueryStr() {
          return queryStr;
      }
  
      public Request2(InputStream is) {
          parameterMap = new HashMap<>();
          byte[] datas = new byte[1024 * 1024];
          int len;
          try {
              len = is.read(datas);
              this.requestInfo = new String(datas, 0, len);
          } catch (IOException e) {
              e.printStackTrace();
              return;
          }
          // 分解字符串
          parseRequestInfo();
      }
  
      private void parseRequestInfo() {
          System.out.println("---分解---");
          System.out.println("1. 获取请求方式：开头到第一个/");
          this.method = this.requestInfo.substring(0, this.requestInfo.indexOf("/")).toLowerCase().trim();
          System.out.println("2. 获取请求url：第一个/ 到HTTP/");
          System.out.println("可能包含请求参数?前面的url");
          // 1. 获取/的位置
          int startIdx = this.requestInfo.indexOf("/") + 1;
          // 2. 获取HTTP/的位置
          int endIdx = this.requestInfo.indexOf("HTTP/");
          // 3. 分割字符串
          this.url = this.requestInfo.substring(startIdx, endIdx);
          // 4. 获取？的位置
          int queryIdx = this.url.indexOf("?");
          if (queryIdx >= 0) {
              // 表示存在请求参数
              String[] urlArray = this.url.split("\\?");
              this.url = urlArray[0].trim();
              queryStr = urlArray[1].trim();
          }
          System.out.println(this.url);
  
          System.out.println("3. 获取请求参数：若果Get已经获取，如果post可能在请求体中");
          if (method.equals("post")) {
              String qStr = this.requestInfo.substring(this.requestInfo.lastIndexOf(CRLF)).trim();
              if (null == queryStr) {
                  queryStr = qStr;
              } else {
                  queryStr += "&" + qStr;
              }
          }
          queryStr = null == queryStr?"": queryStr;
          System.out.println(method + "-->" + url + "-->" + queryStr);
          // 转成Map    fav=1&fav=2&uname=shsxt&age=18&other=
          convertMap();
      }
  
      // 处理请求参数为Map
      private void convertMap(){
          // 分割字符串 &
          String[] keyValues = this.queryStr.split("&");
          for(String queryStr: keyValues){
              // 再次分割字符串 =
              String[] kv = queryStr.split("=");
              // 保持两个长度 key 和 value
              kv = Arrays.copyOf(kv, 2);
              // 获取key 和 value
              String key = kv[0];
              String value = kv[1]==null? null: decode(kv[1], "utf-8");
              // 存储在Map中
              if(!parameterMap.containsKey(key)){
                  // 容器里面没有，第一次
                  parameterMap.put(key, new ArrayList<String>());
              }
              parameterMap.get(key).add(value);
          }
      }
  
      // 处理中文
      private String decode(String value, String enc){
          try {
              return java.net.URLDecoder.decode(value, enc);
          } catch (UnsupportedEncodingException e) {
              e.printStackTrace();
              return null;
          }
      }
  
      // 通过name获取对应的多个值
      public String[] getParameterValues(String key){
          List<String> values = this.parameterMap.get(key);
          if(null == values || values.size()<1){
              return null;
          }
          return values.toArray(new String[0]);
      }
  
      // 通过name获取对应的一个值
      public String getParameter(String key){
          String[] values = getParameterValues(key);
          return values == null?null: values[0];
      }
  }
  ```

  ```java
  package com.sxt.Server_study02;
  
  import java.io.IOException;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server05.java
   * @time: 2019/12/4 9:26
   * @desc: 封装请求信息中参数转成map
   */
  
  public class Server05 {
      private ServerSocket serverSocket;
      public static void main(String[] args) {
          Server05 server = new Server05();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
          }
      }
  
      // 接受连接处理
      public void receive() {
          try {
              Socket client = serverSocket.accept();
              System.out.println("一个客户端建立了连接...");
              // 获取请求协议
              Request2 request = new Request2(client);
  
              Response response = new Response(client);
  
              // 关注了内容
              response.print("<html>");
              response.print("<head>");
              response.print("<title>");
              response.print("服务器响应成功");
              response.print("</title>");
              response.print("</head>");
              response.print("<body>");
              response.print("终于回来了..." + request.getParameter("uname"));
              response.print("</body>");
              response.print("</html>");
  
              // 关注了状态码
              response.pushToBrowser(200);
  
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("客户端错误...");
          }
      }
  
      // 停止服务
      public void stop() {
  
      }
  }
  ```

### 11. 引入servlet

- 加入了Servlet解耦了业务代码

  ```java
  package com.sxt.Server_study03;
  
  import com.sxt.tcp.Server;
  
  import java.io.IOException;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server06.java
   * @time: 2019/12/4 9:26
   * @desc: 加入了Servlet解耦了业务代码
   */
  
  public class Server06 {
      private ServerSocket serverSocket;
      public static void main(String[] args) {
          Server06 server = new Server06();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
          }
      }
  
      // 接受连接处理
      public void receive() {
          try {
              Socket client = serverSocket.accept();
              System.out.println("一个客户端建立了连接...");
              // 获取请求协议
              Request request = new Request(client);
              Response response = new Response(client);
  
              // 关注了内容
              Servlet servlet = null;
              if(request.getUrl().equals("login")){
                  servlet = new LoginServlet();
              }else if (request.getUrl().equals("reg")){
                  servlet = new RegisterServlet();
              }else {
                  // 首页
              }
  
              servlet.service(request, response);
  
  
              // 关注了状态码
              response.pushToBrowser(200);
  
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("客户端错误...");
          }
      }
  
      // 停止服务
      public void stop() {
  
      }
  }
  ```

- Request和Response同上

- Servlet

  ```java
  package com.sxt.Server_study03;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Servlet.java
   * @time: 2019/12/9 12:03
   * @desc: 服务器小脚本接口
   */
  
  public interface Servlet {
      void service(Request request, Response response);
  }
  ```

- RegisterServlet

  ```java
  package com.sxt.Server_study03;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: RegisterServlet.java
   * @time: 2019/12/3 15:59
   * @desc:
   */
  
  public class RegisterServlet implements Servlet{
      @Override
      public void service(Request request, Response response){
          response.print("注册成功...");
      }
  }
  ```

- LoginServlet

  ```java
  package com.sxt.Server_study03;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: LoginServlet.java
   * @time: 2019/12/3 15:59
   * @desc:
   */
  
  public class LoginServlet implements Servlet {
      @Override
      public void service(Request request, Response response) {
          response.print("<html>");
          response.print("<head>");
          response.print("<title>");
          response.print("第一个servlet");
          response.print("</title>");
          response.print("</head>");
          response.print("<body>");
          response.print("欢迎回来..." + request.getParameter("uname"));
          response.print("</body>");
          response.print("</html>");
      }
  }
  ```

### 12. 整合webxml

- 将之前的Mapping，Entity，WebContext，WebHandler拷贝到工程中

- 解析web.xml代码

  ```java
  package com.sxt.Server_study03;
  
  import com.sxt.Server_study01.servlet.WebContext;
  
  import javax.xml.parsers.SAXParser;
  import javax.xml.parsers.SAXParserFactory;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: WebApp.java
   * @time: 2019/12/9 12:37
   * @desc: 解析代码
   */
  
  public class WebApp {
      private static WebContext context;
  
      static {
          try {
              // SAX解析
              // 1. 获取解析工厂
              SAXParserFactory factory = SAXParserFactory.newInstance();
              // 2. 从解析工厂获取解析器
              SAXParser parse = null;
              parse = factory.newSAXParser();
              // 3. 加载文档Document注册处理器
              // 4. 编写处理器
              WebHandler handler = new WebHandler();
              parse.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("web.xml"), handler);
              // 5. 获取数据
              context = new WebContext(handler.getEntitys(), handler.getMappings());
  
          } catch (Exception e) {
              System.out.println("解析配置文件错误！");
          }
      }
  
      // 通过url获取配置文件对应的servlet
      public static Servlet getServletFromUrl(String url) {
          // 假设你输入了 /login or /g or /reg
          String className = context.getClz("/" + url);
          Class clz = null;
          try {
              clz = Class.forName(className);
              Servlet servlet = (Servlet) clz.getConstructor().newInstance();
              return servlet;
          } catch (Exception e) {
              e.printStackTrace();
          }
          return null;
      }
  }
  ```

- 新增OthersServlet

  ```java
  package com.sxt.Server_study03;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: OthersServlet.java
   * @time: 2019/12/9 13:17
   * @desc: 其他测试页面
   */
  
  public class OthersServlet implements Servlet{
      @Override
      public void service(Request request, Response response) {
          response.print("其他测试页面...");
      }
  }
  ```

- 修改xml

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app>
      <servlet>
          <servlet-name>login</servlet-name>
          <servlet-class>com.sxt.Server_study03.LoginServlet</servlet-class>
      </servlet>
      <servlet>
          <servlet-name>reg</servlet-name>
          <servlet-class>com.sxt.Server_study03.RegisterServlet</servlet-class>
      </servlet>
      <servlet-mapping>
          <servlet-name>login</servlet-name>
          <url-pattern>/login</url-pattern>
          <url-pattern>/g</url-pattern>
      </servlet-mapping>
      <servlet-mapping>
          <servlet-name>reg</servlet-name>
          <url-pattern>/reg</url-pattern>
      </servlet-mapping>
      <servlet>
          <servlet-name>others</servlet-name>
          <servlet-class>com.sxt.Server_study03.OthersServlet</servlet-class>
      </servlet>
      <servlet-mapping>
          <servlet-name>others</servlet-name>
          <url-pattern>/o</url-pattern>
      </servlet-mapping>
  </web-app>
  ```

- 整合配置文件

  ```java
  package com.sxt.Server_study03;
  
  import java.io.IOException;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server06.java
   * @time: 2019/12/4 9:26
   * @desc: 整合配置文件
   */
  
  public class Server07 {
      private ServerSocket serverSocket;
      public static void main(String[] args) {
          Server07 server = new Server07();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
          }
      }
  
      // 接受连接处理
      public void receive() {
          try {
              Socket client = serverSocket.accept();
              System.out.println("一个客户端建立了连接...");
              // 获取请求协议
              Request request = new Request(client);
              Response response = new Response(client);
  
              Servlet servlet = WebApp.getServletFromUrl(request.getUrl());
              if(null != servlet){
                  servlet.service(request, response);
                  // 关注了状态码
                  response.pushToBrowser(200);
              }else {
                  // 错误页面...
                  response.pushToBrowser(404);
              }
  
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("客户端错误...");
          }
      }
  
      // 停止服务
      public void stop() {
  
      }
  }
  ```

### 13. 高效分发器

- 多线程处理，加入分发器

  ```java
  package com.sxt.Server_study03;
  
  import java.io.IOException;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server08.java
   * @time: 2019/12/4 9:26
   * @desc: 多线程处理，加入分发器
   */
  
  public class Server08 {
      private ServerSocket serverSocket;
      private boolean isRunning;
  
      public static void main(String[] args) {
          Server08 server = new Server08();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              isRunning = true;
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
              stop();
          }
      }
  
      // 接受连接处理
      public void receive() {
          while (isRunning) {
              try {
                  Socket client = serverSocket.accept();
                  System.out.println("一个客户端建立了连接...");
                  // 多线程处理
                  new Thread(new Dispatcher(client)).start();
              } catch (IOException e) {
                  e.printStackTrace();
                  System.out.println("客户端错误...");
              }
          }
      }
  
      // 停止服务
      public void stop() {
          isRunning = false;
          try {
              this.serverSocket.close();
              System.out.println("服务器已停止...");
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

- 分发器

  ```java
  package com.sxt.Server_study03;
  
  import java.io.IOException;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Dispatcher.java
   * @time: 2019/12/12 16:36
   * @desc: 分发器
   */
  
  public class Dispatcher implements Runnable {
      private Socket client;
      private Request request;
      private Response response;
  
      public Dispatcher(Socket client) {
          this.client = client;
          try {
              // 获取请求和响应
              request = new Request(client);
              response = new Response(client);
          } catch (IOException e) {
              e.printStackTrace();
              this.release();
          }
      }
  
      @Override
      public void run() {
          try {
              Servlet servlet = WebApp.getServletFromUrl(request.getUrl());
              if (null != servlet) {
                  servlet.service(request, response);
                  // 关注了状态码
                  response.pushToBrowser(200);
              } else {
                  // 错误页面...
                  response.pushToBrowser(404);
              }
          }catch (Exception e){
              try {
                  response.pushToBrowser(500);
              } catch (IOException ex) {
                  ex.printStackTrace();
              }
          }
          release();
      }
  
      // 释放资源
      private void release() {
          try {
              client.close();
          } catch (IOException ex) {
              ex.printStackTrace();
          }
      }
  }
  ```

### 14. 经典404及首页处理

- 这一部分有问题is.readAllBytes()这里报错，并且也没有找到解决办法

- 分发器

  ```java
  package com.sxt.Server_study03;
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.net.Socket;
  import java.nio.file.Files;
  import java.nio.file.Paths;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Dispatcher.java
   * @time: 2019/12/12 16:36
   * @desc: 分发器
   */
  
  public class Dispatcher implements Runnable {
      private Socket client;
      private Request request;
      private Response response;
  
      public Dispatcher(Socket client) {
          this.client = client;
          try {
              // 获取请求和响应
              request = new Request(client);
              response = new Response(client);
          } catch (IOException e) {
              e.printStackTrace();
              this.release();
          }
      }
  
      @Override
      public void run() {
          try {
              if (null == request.getUrl() || request.getUrl().equals("")) {
                  InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("index.html");
                  response.print(new String(is.readAllBytes()));
                  response.println(new String(Files.readAllBytes(Paths.get("index.html"))));
                  response.pushToBrowser(200);
                  is.close();
                  return;
              }
              Servlet servlet = WebApp.getServletFromUrl(request.getUrl());
              if (null != servlet) {
                  servlet.service(request, response);
                  // 关注了状态码
                  response.pushToBrowser(200);
              } else {
                  InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("error.html");
                  response.print(new String(is.readAllBytes()));
                  response.pushToBrowser(404);
                  is.close();
              }
          } catch (Exception e) {
              try {
                  response.print("你好我不好，我会马上好");
                  response.pushToBrowser(500);
              } catch (IOException ex) {
                  ex.printStackTrace();
              }
          }
          release();
      }
  
      // 释放资源
      private void release() {
          try {
              client.close();
          } catch (IOException ex) {
              ex.printStackTrace();
          }
      }
  }
  ```

- 处理404/505和首页

  ```java
  package com.sxt.Server_study03;
  
  import java.io.IOException;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server08.java
   * @time: 2019/12/4 9:26
   * @desc: 处理404/505和首页
   */
  
  public class Server09 {
      private ServerSocket serverSocket;
      private boolean isRunning;
  
      public static void main(String[] args) {
          Server09 server = new Server09();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              isRunning = true;
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
              stop();
          }
      }
  
      // 接受连接处理
      public void receive() {
          while (isRunning) {
              try {
                  Socket client = serverSocket.accept();
                  System.out.println("一个客户端建立了连接...");
                  // 多线程处理
                  new Thread(new Dispatcher(client)).start();
              } catch (IOException e) {
                  e.printStackTrace();
                  System.out.println("客户端错误...");
              }
          }
      }
  
      // 停止服务
      public void stop() {
          isRunning = false;
          try {
              this.serverSocket.close();
              System.out.println("服务器已停止...");
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

## 第2章 注解+反射+字节码+类加载机制

### 1. 内置注解

- Annotation

- 作用

  - 不是程序本身，可以对程序作出解释。
  - 可以被其他程序（比如：编译器等）读取。

- 格式

  - @注解名

  ```java
  package com.sxt.test.annotation;
  
  import java.util.ArrayList;
  import java.util.Date;
  import java.util.List;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Demo01.java
   * @time: 2019/12/16 9:34
   * @desc:
   */
  
  public class Demo01 {
      @Override
      // 重写父类方法
      public String toString() {
          return "";
      }
  
      @Deprecated
      // 该方法不建议使用
      public static void test1() {
          System.out.println("你大爷");
      }
  
      @SuppressWarnings("all")
      // 不显示所有警告信息
      public static void test2() {
          List list = new ArrayList();
      }
  
      @SuppressWarnings(value = {"unchecked", "deprecation"})
      // 不显示某几个警告信息
      public static void main(String[] args) {
          test1();
      }
  }
  ```

### 2. 自定义注解

- 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口
- 要点
  - interface用来声明一个注解
  - 格式为：public @interface 注解名 {定义体}
- 其中的每一个方法实际上是声明了一个配置参数
  - 方法的名称就是参数的名称
  - 返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。
  - 可以通过default来声明参数的默认值
  - 如果只有一个参数成员，一般参数名为value
- 元注解
  - 负责注解其他注解。
  - @Target：用于描述注解的使用范围
  - @Retention：表示需要在什么级别保存该注解信息，用于描述注解的生命周期
  - @Documented
  - @Inherited

### 3. 反射机制读取注解

- ORM：Object Relationship Mapping，对象关系映射

  - 类和表结构对应
  - 属性和字段对应
  - 对象和记录对应

- 使用注解完成类和表结构的映射关系

  - 类注解

    ```java
    package com.sxt.test.annotation;
    
    import java.lang.annotation.ElementType;
    import java.lang.annotation.Retention;
    import java.lang.annotation.RetentionPolicy;
    import java.lang.annotation.Target;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LTTable.java
     * @time: 2019/12/16 12:44
     * @desc:
     */
    
    @Target(value = {ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface LTTable {
        String value();
    }
    ```

  - 属性注解

    ```java
    package com.sxt.test.annotation;
    
    import java.lang.annotation.ElementType;
    import java.lang.annotation.Retention;
    import java.lang.annotation.RetentionPolicy;
    import java.lang.annotation.Target;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LTField.java
     * @time: 2019/12/16 12:46
     * @desc: 说明属性的特征
     */
    
    @Target(value = {ElementType.FIELD})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface LTField {
        String columnName();
        String type();
        int length();
    }
    ```

  - 学生类

    ```java
    package com.sxt.test.annotation;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Student.java
     * @time: 2019/12/16 12:43
     * @desc:
     */
    
    @LTTable("tb_student")
    public class Student {
    
        @LTField(columnName = "id", type = "int", length = 10)
        private int id;
        @LTField(columnName = "sname", type = "varchar", length = 10)
        private String studentName;
        @LTField(columnName = "age", type = "int", length = 3)
        private int age;
    
        public int getId() {
            return id;
        }
    
        public void setId(int id) {
            this.id = id;
        }
    
        public String getStudentName() {
            return studentName;
        }
    
        public void setStudentName(String studentName) {
            this.studentName = studentName;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    }
    ```

  - 使用反射读取注解的信息，模拟处理注解信息的流程

    ```java
    package com.sxt.test.annotation;
    
    import java.lang.annotation.Annotation;
    import java.lang.reflect.Field;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Demo03.java
     * @time: 2019/12/16 12:49
     * @desc: 使用反射读取注解的信息，模拟处理注解信息的流程
     */
    
    public class Demo03 {
        public static void main(String[] args) {
            try {
                Class clazz = Class.forName("com.sxt.test.annotation.Student");
    
                // 获得类的所有有效注解
                Annotation[] annotations = clazz.getAnnotations();
                for (Annotation a : annotations) {
                    System.out.println(a);
                }
    
                // 获得类的指定的注解
                LTTable st = (LTTable) clazz.getAnnotation(LTTable.class);
                System.out.println(st.value());
    
                // 获得类的属性的注解
                Field f = clazz.getDeclaredField("studentName");
                LTField ltField = f.getAnnotation(LTField.class);
                System.out.println(ltField.columnName()+"-->"+ltField.type()+"-->"+ltField.length());
    
                // 根据获得的表明、字段的信息，拼出DDL语句，然后使用JDBC执行这个SQL，在数据库中生成相关的表
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    ```

### 4. 反射机制

- 介绍+Class对象获取

  - 动态语言：程序运行时，可以改变程序结构或变态类型。（如python、javascript）

  - Java不是动态语言，但可以称为“准动态语言”。Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。

  - 反射机制

    - 指的是可以于运行时加载、探知、使用编译期间完全未知的类。

  - 测试各种类型对应的java.lang.Class对象的获取方式

    ```java
    package com.sxt.test.reflection;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Demo01.java
     * @time: 2019/12/17 18:59
     * @desc: 测试各种类型对应的java.lang.Class对象的获取方式
     */
    
    public class Demo01 {
        public static void main(String[] args) {
            String path = "com.sxt.test.bean.User";
            try {
                Class clazz = Class.forName(path);
                // 对象是表示或封装一些数据。一个类被加载后，JVM会创建一个对应该类的Class对象，
                // 类的整个结构信息会放到对应的Class对象中。这个Class对象就像一面镜子一样，
                // 通过这面镜子我们可以看到对应类的全部信息。
                System.out.println(clazz);
                System.out.println(clazz.hashCode());
    
                // 一个类只对应一个Class对象
                Class clazz2 = Class.forName(path);
                System.out.println(clazz2.hashCode());
    
                Class strClazz = String.class;
                Class strClazz2 = path.getClass();
                // 获得的都是String的Class对象
                System.out.println(strClazz==strClazz2);
    
                Class intClazz = int.class;
                System.out.println(intClazz.hashCode());
    
                // 数组跟维度、类型都有关
                int[] arr01 = new int[10];
                int[] arr02 = new int[30];
                int[][] arr03 = new int[10][10];
                double[] arr04 = new double[10];
                System.out.println(arr01.getClass().hashCode() == arr02.getClass().hashCode());
                System.out.println(arr01.getClass().hashCode() == arr03.getClass().hashCode());
                System.out.println(arr01.getClass().hashCode() == arr04.getClass().hashCode());
    
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    ```

- 动态操作+构造器+方法+属性

- 提高反射效率+操作泛型+操作注解

------

我的CSDN：https://blog.csdn.net/qq_21579045

我的博客园：https://www.cnblogs.com/lyjun/

我的Github：https://github.com/TinyHandsome

纸上得来终觉浅，绝知此事要躬行~

欢迎大家过来OB~

by 李英俊小朋友